package dm

import (
    "bytes"
    "compress/gzip"
    _ "embed"
    "io"

    "github.com/tawesoft/golib/v2/must"
)

// dtiBin contains packed Unicode decomposition type data (not worth gziping)
//go:embed dti.bin
var dtiBin []byte // generated by internal/unicode/gen.sh

// dtis is an index of decomposition types and index to mappings
var dtis []dti

type dti struct {
    codepoint rune
    dt  Type // decomposition type
    dmi int16 // decomposition mapping index
    dml int16 // decomposition mapping length (number of mappings)
}

// dmsBin contains packed Unicode decomposition mapping data
//go:embed dms.bin.gz
var dmsBinGz []byte // generated by internal/unicode/gen.sh

// dms is a list of decomposition mappings, indexed by dti.dmi
var dms []rune

// ungz unpacks gzipped data
func ungz(src []byte) []byte {
    rdr := must.Result(gzip.NewReader(bytes.NewReader(src)))
    defer rdr.Close()
    return must.Result(io.ReadAll(rdr))
}

func dtiDecode(x uint64) dti {
    cp  := (x      ) & 0x1FFFFF
    dt  := (x >> 21) & 0x1F
    dml := (x >> 26) & 0x1F
    dmi := (x >> 31) & 0xFFFF
    return dti{
        codepoint: rune(cp),
         dt: Type(dt),
        dml: int16(dml),
        dmi: int16(dmi),
    }
}

func init() {
    // unpack dtiBin => dtis
    {
        dtis = make([]dti, len(dtiBin) / 6)
        bytes := dtiBin

        for i := 0; i < len(dtis); i++ {
            b0 := bytes[0]
            b1 := bytes[1]
            b2 := bytes[2]
            b3 := bytes[3]
            b4 := bytes[4]
            b5 := bytes[5]
            bytes = bytes[6:]
            x :=
                uint64(b0)         |
                (uint64(b1) <<  8) |
                (uint64(b2) << 16) |
                (uint64(b3) << 24) |
                (uint64(b4) << 32) |
                (uint64(b5) << 40)
            dtis[i] = dtiDecode(x)
        }
    }

    // unpack dmsBin => dms
    {
        dmsBin := ungz(dmsBinGz)
        dms = make([]rune, len(dmsBin) / 3)
        bytes := dmsBin

        for i := 0; i < len(dms); i++ {
            b0 := bytes[0]
            b1 := bytes[1]
            b2 := bytes[2]
            bytes = bytes[3:]
            x :=
                uint32(b0)         |
                (uint32(b1) <<  8) |
                (uint32(b2) << 16)
            dms[i] = rune(x)
        }
    }
}
