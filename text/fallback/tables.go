package fallback

import (
    "bytes"
    _ "embed"
    "encoding/binary"
    "sort"

    "github.com/tawesoft/golib/v2/ks"
    "github.com/tawesoft/golib/v2/must"
)

// dstarts contains packed Unicode data (not worth gziping) mapping the first
// character of a decomposition to the list of codepoints that generate a
// decomposition starting with that character.
//go:embed dstarts.bin
var dstartsBin []byte // generated by internal/unicode/gen.sh

// dsi is the decomposition starters index
type dsi struct {
    codepoint rune // first character of a decomposition
    cpsi uint16 // codepoints index
}

// dsis is a sorted list of dsi elements
var dsis []dsi

// cps is a sorted list of utf8 encoded strings of codepoints that dsi points to
var cps []byte

// dstarts returns all characters whose canonical decomposition starts with
// the given rune. The result is a utf8-encoded string.
func dstarts(x rune) []byte {
    n := len(dsis)
    i := sort.Search(n, func(i int) bool {
        return x <= dsis[i].codepoint
    })

    if (i == n) || (dsis[i].codepoint != x) {
        return nil
    }

    var z int
    if i + 1 < n {
        // length is found by subtracting offset of next item
        z = int(dsis[i + 1].cpsi) - int(dsis[i].cpsi)
        ks.Assert(z > 0)
    } else {
        // length is found relative to end
        z = len(cps) - int(dsis[i].cpsi)
    }

    start := int(dsis[i].cpsi)
    return cps[start : start + z]
}

// getsubs returns Unicode fallback substitutions from Unicode CLDR
// supplemental/characters.xml
func getsubs(x rune) []string {
    n := len(subs)
    i := sort.Search(n, func(i int) bool {
        return x <= subs[i].codepoint
    })

    if (i == n) || (subs[i].codepoint != x) {
        return nil
    }

    return subs[i].alts
}

func init() {
    rdr := bytes.NewReader(dstartsBin[0:4])
    var nIdx int32
    must.Check(binary.Read(rdr, binary.LittleEndian, &nIdx))

    in := dstartsBin[4:4+(nIdx*5)]

    // unpack index
    {
        dsis = make([]dsi, nIdx)

        for i := 0; i < int(nIdx); i++ {
            b0 := in[0]
            b1 := in[1]
            b2 := in[2]
            b3 := in[3]
            b4 := in[4]
            in = in[5:]

            var codepoint = rune(uint32(b0) + (uint32(b1) << 8) + (uint32(b2) << 16))
            var offset    = uint16(rune(uint32(b3) + (uint32(b4) << 8)))

            dsis[i] = dsi{codepoint, offset}
        }
    }

    // remainder is the utf8 encoded points
    cps = dstartsBin[4+(nIdx*5):]
}
