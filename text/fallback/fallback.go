// Package fallback implements Unicode Character Fallback Substitutions using
// the Unicode CLDR 41.0 supplemental data file characters.xml, Go's
// packaged Unicode normalisation rules for canonical decomposition, and
// rules from a matching version of Unicode for compatibility decomposition.
//
// This can be useful for robustly parsing Unicode strings where for practical
// reasons (e.g. missing keyboard keys, missing font support), certain
// fallbacks have been used, or for picking a sensible default when certain
// Unicode strings cannot be displayed (e.g. missing font support).
//
// Note that care must be taken not to change the meaning of a text - for
// example, superscript two '²', will have a (last resort) Character Fallback
// Substitution to the digit '2' via NKFC normalisation, but these have
// entirely different meanings. See the (withdrawn draft) Unicode Technical
// Report [30: CHARACTER FOLDINGS], as well as the earlier draft Unicode
// Technical Report [25: CHARACTER FOLDINGS], for commentary.
//
// [30: CHARACTER FOLDINGS]: http://www.unicode.org/reports/tr30/tr30-4.html
// [25: CHARACTER FOLDINGS]: http://www.unicode.org/L2/L2000/00261-tr25-0d1.html
package main

import (
    "fmt"

    "golang.org/x/text/unicode/norm"
)

/*
func New() {
}
*/

// Is returns true iff the provided string is a possible fallback string
// generated by Unicode Character Fallback Substitution rules applied to the
// input rune. Neither argument is required to be normalised on input.
//
// For example,
//
//   Is('㎦', "㎞³") // true
//   Is('㎦', "km³") // true
//   Is('㎦', "km3") // true
//   Is('㎦', "km3", Options...) // false
func Is(r rune, s string) bool {
    // TODO make this a method on Fallbacker, with options

    // 1. toNFC(value)
    // 2. other canonically equivalent sequences, if there are any
    // Two sequences are canonically equivalent if
    //   * toNFD(a) == toNFD(b), or
    //   * toNFC(a) == toNFC(b)

    q := string(r)
    if !norm.NFC.IsNormalString(q) { q = norm.NFC.String(q) }
    if !norm.NFC.IsNormalString(s) { s = norm.NFC.String(s) }
    if q == s { return true }

    // 3. the explicit substitutes value from characters.xml (in order)
    if q == "₤" {
        if s == "L." { return true }
        if s == "£"  { return true }
    }

    if q == "㎦" {
        if s == "km³" { return true }
    }

    // 4. toNFKC(value)
    // TODO from internal rules, apply options to compatibility type
    if norm.NFKC.String(q) == norm.NFKC.String(s) { return true }

    return false
}

func subs(x rune) []string {
    nfc, nfkc := norm.NFC, norm.NFKC
    s := string(x)
    xs := make([]string, 0)
    xs = append(xs, s)

    if !nfc.IsNormalString(s) {
        sn := nfc.String(s)
        xs = append(xs, sn)
    }

    // https://unicode.org/notes/tn5/#Enumerating_Equivalent_Strings

    // from supplemental/characters.xml
    if s == "₤" {
        xs = append(xs, "L.")
        xs = append(xs, "£")
    }

    if s == "㎦" {
        xs = append(xs, "km³")
    }

    if !nfkc.IsNormalString(s) {
        sn := nfkc.String(s)
        xs = append(xs, sn)
    }

    return xs
}

func main() {

    fmt.Println(norm.NFD.String("㎦"))
    fmt.Println(norm.NFD.String("㎞³"))
    fmt.Println(norm.NFKD.String("㎦"))
    fmt.Println(norm.NFKD.String("㎞³"))

    fmt.Println(Is('㎦', "km³"))
    fmt.Println(Is('㎦', "㎞³"))
    fmt.Println(Is('㎦', "km3"))

    // https://unicode-org.github.io/cldr-staging/charts/41/supplemental/character_fallback_substitutions.html
/*
toNFC(value)
other canonically equivalent sequences, if there are any ???
the explicit substitutes value from characters.xml (in order)
toNFKC(value)
*/
/*
http://www.unicode.org/L2/L1999/UnicodeData.html


Character Decomposition
The decomposition is a normative property of a character. The tags supplied with certain decomposition mappings generally indicate formatting information. Where no such tag is given, the mapping is designated as canonical. Conversely, the presence of a formatting tag also indicates that the mapping is a compatibility mapping and not a canonical mapping. In the absence of other formatting information in a compatibility mapping, the tag is used to distinguish it from canonical mappings.

In some instances a canonical mapping or a compatibility mapping may consist of a single character. For a canonical mapping, this indicates that the character is a canonical equivalent of another single character. For a compatibility mapping, this indicates that the character is a compatibility equivalent of another single character. The compatibility formatting tags used are:

Tag
Description

<font>  	A font variant (e.g. a blackletter form).
<noBreak>  	A no-break version of a space or hyphen.
<initial>  	An initial presentation form (Arabic).
<medial>  	A medial presentation form (Arabic).
<final>  	A final presentation form (Arabic).
<isolated>  	An isolated presentation form (Arabic).
<circle>  	An encircled form.
<super>  	A superscript form.
<sub>  	A subscript form.
<vertical>  	A vertical layout presentation form.
<wide>  	A wide (or zenkaku) compatibility character.
<narrow>  	A narrow (or hankaku) compatibility character.
<small>  	A small variant form (CNS compatibility).
<square>  	A CJK squared font variant.
<fraction>  	A vulgar fraction form.
<compat>  	Otherwise unspecified compatibility character.


Reminder: There is a difference between decomposition and decomposition mapping. The decomposition mappings are defined in the UnicodeData, while the decomposition (also termed "full decomposition") is defined in Chapter 3 to use those mappings recursively.

The canonical decomposition is formed by recursively applying the canonical mappings, then applying the canonical reordering algorithm.
The compatibility decomposition is formed by recursively applying the canonical and compatibility mappings, then applying the canonical reordering algorithm.


http://www.unicode.org/reports/tr42/#d1e2932

4.4.8 Decomposition properties
The decomposition type and decomposition mapping properties are represented by the dt and dm attributes.

Most characters have a decomposition mapping to themselves. This is very similar to the situation we encountered with names, and we adopted a similar convention: if the value of a decomposition mapping is the character itself, we use the attribute value # (U+0023 # NUMBER SIGN) as a shorthand notation; this enables those attributes to be captured in groups.

[decomposition properties, 23] =
  code-point-attributes &=
    attribute dt { "can"  | "com" | "enc" | "fin"  | "font" | "fra"
                 | "init" | "iso" | "med" | "nar"  | "nb"   | "sml"
                 | "sqr"  | "sub" | "sup" | "vert" | "wide" | "none"}?

  code-point-attributes &=
    attribute dm { "#" | zero-or-more-code-points }?


4.4.9 Numeric Properties
The numeric type is represented by the nt attribute.

The numeric value is represented by the nv attribute, represented as a fraction.

[numeric properties, 26] =
  code-point-attributes &=
    attribute nt { "None" | "De" | "Di" | "Nu" }?

  code-point-attributes &=
    attribute nv { "NaN" | xsd:string { pattern = "-?[0-9]+(/[0-9]+)?" }}?
 */

    fmt.Printf("%v\n", subs('㎦'))
}
