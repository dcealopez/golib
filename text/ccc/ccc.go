// Package ccc returns the Unicode [Canonical Combining Class] value for a
// codepoint.
//
// [Canonical Combining Class: https://unicode.org/reports/tr44/#Canonical_Combining_Class_Values
package ccc

import (
    _ "embed"
    "fmt"
    "sort"
    "unicode/utf8"

    "github.com/tawesoft/golib/v2/ks"
    "golang.org/x/text/transform"
)

const maxSeenNonStarters = 30

// cccBin contains packed Unicode Canonical Combining Class values
// for ordered ranges of codepoints (not worth gziping)
//go:embed ccc.bin
var cccBin []byte // generated by internal/unicode/gen.sh

// cccs is an ordered table of Unicode Canonical Combining Class values for
// ranges of codepoints.
var cccs []cccRange

type cccRange struct {
    Start rune
    End   rune
    Ccc   CCC
}

func cccDecode(x uint64) cccRange {
    cp  := (x      ) & 0x1FFFFF
    cl  := (x >> 21) & 0x7FF
    cls := (x >> 32) & 0xFF
    return cccRange{
        Start: rune(cp),
        End: rune(cp) + rune(cl),
        Ccc: CCC(cls),
    }
}

func init() {
    // unpack cccBin => cccs
    {
        cccs = make([]cccRange, len(cccBin) / 5)
        bytes := cccBin

        for i := 0; i < len(cccs); i++ {
            b0 := bytes[0]
            b1 := bytes[1]
            b2 := bytes[2]
            b3 := bytes[3]
            b4 := bytes[4]
            bytes = bytes[5:]
            x :=
                uint64(b0)         |
                (uint64(b1) <<  8) |
                (uint64(b2) << 16) |
                (uint64(b3) << 24) |
                (uint64(b4) << 32)
            cccs[i] = cccDecode(x)
        }
    }
}

// CCC is a Unicode Canonical Combining Class value
type CCC uint8

// Of returns the Unicode Canonical Combining Class for a specific codepoint.
// Note that we do not distinguish between CCC(0) (Not_Reordered) and a missing
// value for an invalid rune.
func Of(c rune) CCC {
    if r, ok := getRange(c); ok {
        return r.Ccc
    }
    return 0
}

// gerRange looks up the range of (start, end, ccc) in the range tables
func getRange(c rune) (cccRange, bool) {
    i, found := sort.Find(len(cccs), func(i int) int {
        if c <  cccs[i].Start { return -1 }
        if c >= cccs[i].End   { return  1 }
        return 0
    })

    if !found {
        return ks.Zero[cccRange](), false
    }

    return cccs[i], true
}

// ReorderRunes performs the Unicode Canonical Ordering Algorithm on a slice of
// runes. If the input is not a [Stream-Safe Text Format] (usually this means
// it is a maliciously crafted input), the ordering is not complete.
//
// [Stream-Safe Text Format]: https://unicode.org/reports/tr15/#Stream_Safe_Text_Format
func ReorderRunes(xs []rune) {

    seenNonStarters := 0

    // algorithm based on Charlint
    for i := 1; i < len(xs); i++ {
        cccHere := Of(xs[i])
        cccPrev := Of(xs[i-1])

        if cccHere == 0 {
            seenNonStarters = 0
        } else {
            seenNonStarters++
        }

        if (cccHere != 0) && (cccPrev > cccHere) {
            tmp := xs[i]
            xs[i] = xs[i-1]
            xs[i-1] = tmp
            if (i > 1) && (seenNonStarters < maxSeenNonStarters) { i-=2 } // backtrack
        }
    }
}

/*
don't want to expose this yet because would also suggest OrderedBytes...
func Ordered(xs []rune) bool {
    for i := 1; i < len(xs); i++ {
        cccHere := Of(xs[i])
        cccPrev := Of(xs[i-1])
        if (cccHere != 0) && (cccPrev > cccHere) {
            return false
        }
    }
    return true
}*/

func ReorderString(xs string) error {
    return Reorder([]byte(xs))
}

// Reorder performs the Unicode Canonical Ordering Algorithm on a slice
// of bytes encoding a UTF-8 sequence.
//
// If the input is not a [Stream-Safe Text Format] (usually this means it is a
// maliciously crafted input), the ordering is not complete.
//
// [Stream-Safe Text Format]: https://unicode.org/reports/tr15/#Stream_Safe_Text_Format
func Reorder(xs []byte) error {
    // Fuller tests for this function are implemented in text/dm

    var (
        prev rune
        prevZ int
        offset int
    )

    seenNonStarters := 0

    for {
        if offset == 0 {
            prev, prevZ = utf8.DecodeRune(xs)
            if prev == utf8.RuneError {
                if prevZ == 0 { // done
                    return nil
                }
                return fmt.Errorf("invalid UTF8 sequence at byte 0x%x", offset)
            }
            offset = prevZ
            continue
        }

        current, currentZ := utf8.DecodeRune(xs[offset:])
        if current == utf8.RuneError {
            if currentZ == 0 { // done
                return nil
            }
            return fmt.Errorf("invalid UTF8 sequence at byte 0x%x", offset)
        }

        cccHere := Of(current)
        cccPrev := Of(prev)

        if cccHere == 0 {
            seenNonStarters = 0
        } else {
            seenNonStarters++
        }

        if (cccHere != 0) && (cccPrev > cccHere) {
            var tmp1, tmp2 [4]byte

            copy(tmp1[:], xs[offset - prevZ : offset])
            copy(tmp2[:], xs[offset : offset + currentZ])

            copy(xs[offset - prevZ : offset - prevZ + currentZ], tmp2[:])
            copy(xs[offset - prevZ + currentZ : offset + currentZ], tmp1[:])

            if (offset > prevZ + currentZ) && (seenNonStarters < maxSeenNonStarters) {
                offset -= prevZ + currentZ
            }
            prev, prevZ = current, currentZ
            continue
        }

        prev, prevZ = current, currentZ
        offset += currentZ
    }
}

func IsStreamSafe(src []byte) bool {
    seenNonstarters := 0
    for len(src) > 0 {
        r, rZ := utf8.DecodeRune(src)
        if r == utf8.RuneError {
            if rZ == 0 { break } // EOF
            return false
        }

        cls := Of(r)
        if cls == 0 {
            seenNonstarters = 0
        } else {
            seenNonstarters++
            if seenNonstarters == maxSeenNonStarters {
                return false
            }
        }
        src = src[rZ:]
    }
    return true
}

func IsStreamSafeRunes(src []rune) bool {
    seenNonstarters := 0
    for len(src) > 0 {
        cls := Of(src[0])
        if cls == 0 {
            seenNonstarters = 0
        } else {
            seenNonstarters++
            if seenNonstarters == maxSeenNonStarters {
                return false
            }
        }
        src = src[1:]
    }
    return true
}

func IsStreamSafeString(src string) bool {
    return IsStreamSafe([]byte(src))
}

// Transformer returns an object implementing the [transform.Transform]
// interface that applies the Unicode Canonical Ordering Algorithm across its
// input. It outputs ordered Unicode.
//
// If the input is not a [Stream-Safe Text Format] (usually this means it is a
// maliciously crafted input), the ordering is not complete.
//
// [Stream-Safe Text Format]: https://unicode.org/reports/tr15/#Stream_Safe_Text_Format
//
// Note that this transformer is stateful, so should not be used concurrently.
func Transformer() transform.Transformer {
    o := &orderer{}
    o.Reset()
    return o
}

// orderer implements the [transform.Transformer] interface.
type orderer struct {
    backing [maxSeenNonStarters]rune
    runes []rune
    ordered bool
    emitting bool
}

func (o *orderer) Reset() {
    o.runes = o.backing[0:0]
    o.ordered = false
    o.emitting = false
}

func (o *orderer) emit(dst, src[]byte, nDst, nSrc int) (int, int, error) {
    if len(o.runes) == 0 { return nDst, nSrc, nil }
    if !o.ordered { ReorderRunes(o.runes); o.ordered = true }
    o.emitting = true

    for len(o.runes) > 0 {
        s := o.runes[0]
        sZ := utf8.RuneLen(s)
        if cap(dst) - nDst < sZ {
            return nDst, nSrc, transform.ErrShortDst
        }
        nDst += utf8.EncodeRune(dst[nDst:], s)
        o.runes = o.runes[1:]
    }

    o.Reset()
    return nDst, nSrc, nil
}

func (o *orderer) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
    for {
        if o.emitting || (len(o.runes) == cap(o.backing)) {
            nDst2, nSrc2, err2 := o.emit(dst, src, nDst, nSrc)
            nDst = nDst2
            nSrc = nSrc2
            if err2 != nil { return nDst, nSrc, err2 }
        }
        ks.Assert(cap(o.runes) == maxSeenNonStarters) // should be static

        r, rZ := utf8.DecodeRune(src[nSrc:])
        if r == utf8.RuneError {
            if (rZ == 0) && (atEOF) {
                return o.emit(dst, src, nDst, nSrc)
            }
            if atEOF { return nDst, nSrc, fmt.Errorf("invalid utf8 sequence") }
            return nDst, nSrc, transform.ErrShortSrc
        }

        cls := Of(r)

        if (cls == 0) && (len(o.runes) > 0) {
            // end of a run of non-starters
            nDst2, nSrc2, err2 := o.emit(dst, src, nDst, nSrc)
            nDst = nDst2
            nSrc = nSrc2
            if err2 != nil { return nDst, nSrc, err2 }
        }

        if (cls == 0) {
            if cap(dst) - nDst < rZ {
                return nDst, nSrc, transform.ErrShortDst
            }
            nSrc += rZ
            nDst += utf8.EncodeRune(dst[nDst:], r)
        } else {
            o.runes = append(o.runes, r)
            nSrc += rZ
        }
    }
}
