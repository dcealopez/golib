// Package ccc returns the Unicode [Canonical Combining Class] value for a
// codepoint.
//
// [Canonical Combining Class: https://unicode.org/reports/tr44/#Canonical_Combining_Class_Values
package ccc

import (
    _ "embed"
    "fmt"
    "sort"
    "unicode/utf8"

    "github.com/tawesoft/golib/v2/ks"
    "golang.org/x/text/transform"
)

const maxSeenNonStarters = 30

var ErrMaxNonStarters = fmt.Errorf("illegal input: contains a sequence of more than %d non-starters", maxSeenNonStarters)

// cccBin contains packed Unicode Canonical Combining Class values
// for ordered ranges of codepoints (not worth gziping)
//go:embed ccc.bin
var cccBin []byte // generated by internal/unicode/gen.sh

// cccs is an ordered table of Unicode Canonical Combining Class values for
// ranges of codepoints.
var cccs []cccRange

type cccRange struct {
    Start rune
    End   rune
    Ccc   CCC
}

func cccDecode(x uint64) cccRange {
    cp  := (x      ) & 0x1FFFFF
    cl  := (x >> 21) & 0x7FF
    cls := (x >> 32) & 0xFF
    return cccRange{
        Start: rune(cp),
        End: rune(cp) + rune(cl),
        Ccc: CCC(cls),
    }
}

func init() {
    // unpack cccBin => cccs
    {
        cccs = make([]cccRange, len(cccBin) / 5)
        bytes := cccBin

        for i := 0; i < len(cccs); i++ {
            b0 := bytes[0]
            b1 := bytes[1]
            b2 := bytes[2]
            b3 := bytes[3]
            b4 := bytes[4]
            bytes = bytes[5:]
            x :=
                uint64(b0)         |
                (uint64(b1) <<  8) |
                (uint64(b2) << 16) |
                (uint64(b3) << 24) |
                (uint64(b4) << 32)
            cccs[i] = cccDecode(x)
        }
    }
}

// CCC is a Unicode Canonical Combining Class value
type CCC uint8

// Of returns the Unicode Canonical Combining Class for a specific codepoint.
// Note that we do not distinguish between CCC(0) (Not_Reordered) and a missing
// value for an invalid rune.
func Of(c rune) CCC {
    if r, ok := getRange(c); ok {
        return r.Ccc
    }
    return 0
}

// getRange looks up the range of (start, end, ccc) in the range tables
func getRange(c rune) (cccRange, bool) {
    i, found := sort.Find(len(cccs), func(i int) int {
        if c <  cccs[i].Start { return -1 }
        if c >= cccs[i].End   { return  1 }
        return 0
    })

    if !found {
        return ks.Zero[cccRange](), false
    }

    return cccs[i], true
}

// ReorderRunes performs the Unicode Canonical Ordering Algorithm on a slice of
// runes.
func ReorderRunes(xs []rune) error {

    seenNonStarters := 0

    // algorithm based on Charlint
    for i := 1; i < len(xs); i++ {
        cccHere := Of(xs[i])
        cccPrev := Of(xs[i-1])

        if cccHere == 0 {
            seenNonStarters = 0
        } else if seenNonStarters < maxSeenNonStarters {
            seenNonStarters++
        } else {
            return ErrMaxNonStarters
        }

        if (cccHere != 0) && (cccPrev > cccHere) {
            tmp := xs[i]
            xs[i] = xs[i-1]
            xs[i-1] = tmp
            if (i > 1) { i-=2 } // backtrack
        }
    }

    return nil
}

/*
don't want to expose this yet because would also suggest OrderedBytes...
func Ordered(xs []rune) bool {
    for i := 1; i < len(xs); i++ {
        cccHere := Of(xs[i])
        cccPrev := Of(xs[i-1])
        if (cccHere != 0) && (cccPrev > cccHere) {
            return false
        }
    }
    return true
}*/

func ReorderString(xs string) error {
    return Reorder([]byte(xs))
}

// Reorder performs the Unicode Canonical Ordering Algorithm on a slice
// of bytes encoding a UTF-8 sequence.
//
// If the input contains more than 30 non-starters in sequence (usually this
// means it is a maliciously crafted input), an error is returned.
func Reorder(xs []byte) error {
    // Fuller tests for this function are implemented in text/dm

    var (
        prev rune
        prevZ int
        offset int
    )

    seenNonStarters := 0

    for {
        if offset == 0 {
            prev, prevZ = utf8.DecodeRune(xs)
            if prev == utf8.RuneError {
                if prevZ == 0 { // done
                    return nil
                }
                return fmt.Errorf("invalid UTF8 sequence at byte 0x%x", offset)
            }
            offset = prevZ
            continue
        }

        current, currentZ := utf8.DecodeRune(xs[offset:])
        if current == utf8.RuneError {
            if currentZ == 0 { // done
                return nil
            }
            return fmt.Errorf("invalid UTF8 sequence at byte 0x%x", offset)
        }

        cccHere := Of(current)
        cccPrev := Of(prev)

        if cccHere == 0 {
            seenNonStarters = 0
        } else if seenNonStarters < maxSeenNonStarters {
            seenNonStarters++
        } else {
            return ErrMaxNonStarters
        }

        if (cccHere != 0) && (cccPrev > cccHere) {
            var tmp1, tmp2 [4]byte

            copy(tmp1[:], xs[offset - prevZ : offset])
            copy(tmp2[:], xs[offset : offset + currentZ])

            copy(xs[offset - prevZ : offset - prevZ + currentZ], tmp2[:])
            copy(xs[offset - prevZ + currentZ : offset + currentZ], tmp1[:])

            if (offset > prevZ + currentZ) {
                offset -= prevZ + currentZ
            }
            prev, prevZ = current, currentZ
            continue
        }

        prev, prevZ = current, currentZ
        offset += currentZ
    }
}

// Transformer implements the [transform.Transform] interface to apply the
// Unicode Canonical Ordering Algorithm across its input. It outputs ordered
// Unicode.
//
// If the input contains more than 30 non-starters in sequence (usually this
// means it is a maliciously crafted input), an error is returned.
//
// The returned transformer is stateless, so may be used concurrently.
var Transformer = transform.Transformer(orderer{})

type orderer struct {}
func (o orderer) Reset() {}

func emit(runes []rune, dst []byte, nDst, nSrc int) (int, int) {
    if len(runes) != 0 { ReorderRunes(runes) }

    for len(runes) > 0 {
        nDst += utf8.EncodeRune(dst[nDst:], runes[0])
        runes = runes[1:]
    }

    return nDst, nSrc
}

func (o orderer) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
    buf := [maxSeenNonStarters]rune{}
    runes := buf[0:0]
    seenNonStarters := 0

    for {
        if (len(runes) >= maxSeenNonStarters) {
            return nDst, nSrc, ErrMaxNonStarters
            //nDst, nSrc = emit(runes, dst, nDst, nSrc)
            //runes = buf[0:0]
            //seenNonStarters = 0
        }
        if (seenNonStarters == 0) && (len(src) - nSrc < (maxSeenNonStarters + 2) * 4) && !atEOF {
            return nDst, nSrc, transform.ErrShortSrc
        }
        if (seenNonStarters == 0) && (cap(dst) - nDst < (maxSeenNonStarters + 2) * 4) {
            return nDst, nSrc, transform.ErrShortDst
        }
        ks.Assert(cap(runes) <= maxSeenNonStarters) // should be static

        r, rZ := utf8.DecodeRune(src[nSrc:])
        if r == utf8.RuneError {
            if (rZ == 0) && (atEOF) {
                nDst, nSrc = emit(runes, dst, nDst, nSrc)
                return nDst, nSrc, nil
            }
            if atEOF { return nDst, nSrc, fmt.Errorf("invalid utf8 sequence") }
            return nDst, nSrc, transform.ErrShortSrc
        }

        cls := Of(r)

        if (cls == 0) && (len(runes) > 0) {
            // end of a run of non-starters
            nDst, nSrc = emit(runes, dst, nDst, nSrc)
            runes = buf[0:0]
            seenNonStarters = 0
        }

        if (cls == 0) {
            if cap(dst) - nDst < rZ {
                return nDst, nSrc, transform.ErrShortDst
            }
            nSrc += rZ
            nDst += utf8.EncodeRune(dst[nDst:], r)
        } else {
            runes = append(runes, r)
            seenNonStarters++
            nSrc += rZ
        }
    }
}
